### 1.运算符的优先级

~~~c
逻辑运算符 ！
算术运算符（*, /, %)
算术运算符（+, -)
关系运算符(<, >, <=, >=)
逻辑运算符 &&
逻辑运算符 |
赋值运算符 == 
~~~

### 2.条件语句和循环语句

~~~c
if语句让我们依据某个表达式的结果来决定是否执行一条或多条连续的语句；
循环语句可以让我们根据某个表达式的结果，重复执行单一或连续多条语句。

条件语句：if-else, switch-case;
switch(表达式)//整数形式
{        
   case 结果1: 
		语句
         break;
	case 结果1: 
		语句
         break;
	default :
		语句
         break;
}

循环语句：while, do-while, for.
	break---循环结束
    continue---结束本层循环，开始下一次循环

~~~

### 3.inline函数

~~~c
将函数声明为inline,表示要求编译器在每个函数的调用点上，将函数的内容展开；
面对一个inline函数，编译器可将该函数的调用操作改为以一份函数代码副本替代。
特点：
    体积小，常被调用，所从事的计算并不复杂，因为编译器要将它在调用的时候展开，所以声明的同时要看到定义。
~~~

### 4.函数

~~~C
返回类型：
    如果函数的返回类型不为void,那么它必须在每个可能的退出点上将值返回；函数中的每条return语句都被用来明确表示该处是函数的退出点；如果函数的最后一条语句不是return，那么最后一条语句之后便是该函数的退出点。如果执行错误的时候，可以用exit(-1)退出(头文件#include <cstdlib>),或者抛出异常。
函数调用：
    调用一个函数的时候，会在内存中建立一块特殊的区域，称为"程序堆栈"，这块特殊区域提供了每个函数参数的存储空间，它也提供了函数所定义的每个对象的内存空间，这些对象称为局部对象，一旦函数调用完成，这块内存就会被释放掉，或者说从堆栈中pop出来。

对象的返回：
    函数定义的对象只存在于函数的执行期间，如果将这些所谓的局部对象的地址返回，则会导致运行错误，因为这块区域在函数执行结束的时候就被舍弃了。如果将对象以传值的方式返回，就可以了。
    
将参数声明为reference的理由：
    1.希望得以直接对所传入的对象进行修改；
    2.降低复制大型对象的额外负担。
    
局部静态对象：
    const vector<int>* seq(int size){
    	static vector<int> elems;
    	//函数的工作逻辑放在这里
   		return &elems;
}
//局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在

cin >> name;//将输入内容定向到具有适当类型的对象身上
函数的返回值通常用来表示运算结果；
只能定义一份，但可以声明多份
为什么不把函数的定义放在头文件，因为同一个程序的多个代码文件可能都会包含这个头文件。
const object的定义只要一出文件之外便不可见，这就意味着可以在多个程序代码中加以定义。
    
~~~

### 5.new & delete

~~~c
int *pi;
pi = new int; //默认的情况下，heap分配的对象，都没有经过初始化
pi = new int(1024); //对象被初始化为1024、
int *pia = new int[24];//分配一个数组
delete pi;//删除前不用检验pi是否为0，编译器会自动进行这项检查
delete [] pi;

从heap分配而来的对象，被称为具有dynamic extent,因为它们是运行时通过new表达式分配的，因此可以持续存活，直到delete表达式加以释放为止。
~~~

### 6.头文件的尖括号和双引号

~~~c
1.如果头文件和包含此文件的程序代码文件在同一个磁盘目录下，使用双引号，如果在不同的磁盘目录下，使用尖括号；
2.如果此文件被认定为标准的或者项目专属的头文件，用尖括号将文件括住，编译器搜索此文件的时候，会先在某些默认的磁盘目录中寻找；如果文件用双引号括住，此文件便认为是用户提供的文件，搜索此文件时会从要包含此文件所在的磁盘目录找起。
~~~

### 7.函数指针

~~~c
1.定义
const vector<int>*(*seq_ptr)(int); //vector知道自己的大小是多少
返回类型是一个指针，参数列表是一个int类型。
初值为0，表示没有指向任何函数，初值也可以赋某个函数的地址。
2.调用
const vector<int> *pseq = seq_ptr(pos);
3.检验操作
if(!seq_ptr){
    报错！
}
4.数组内存放函数指针
const vector<int>* (*seq_ptr[])(int) = {fibon_seq, lucas_seq, triang_seq}
~~~

