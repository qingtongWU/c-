# c++01命名空间，new,const&引用

## 基本概念

~~~c++
c++文件在vim中用 .cc 或 .cpp结尾；
编译时： 
    a. g++ hello.cc -- 生成一个 a.out文件
    b. g++ *.cc -- 编译当前文件夹下的所有.cc文件
头文件不用加 .h，因为c++头文件是用模板编写的，必须要知道所有实现以后才能编译。

c++头文件路径：/usr/include/c++
函数的声明可以有很多次，但定义只能有一次
    
vim中的注释：
    1. /* ... */
    2. //
    3. #if 0
    	...
       #endif

<< 输出流运算符 -- 以追加模式重定向写入
endl(end of line) -- 换行
    

~~~

## 运算符重载

~~~c++
//作用于左边的操作符
operator<<(cout,"helloworld");//两参数版本
cout.operator<<(endl);//一参数版本

operator<<(cout,"hello world").operator<<(endl);
~~~

## 命名空间

~~~c++
c语言中解决名字冲突
	hwcppprojectABprint()
   公司 项目组 项目 成员
    
c++中用命名空间
    
每个名字空间都是一个名字空间域，存放在名字空间域中的全局实体只在本空间域内有效。名字空间对全局实体加以域的限制，从而合理的解决命名冲突。
    
命名空间可以定义变量函数，结构体类，命名空间等，统一称为实体
可以存放的类型：
	变量
	常量
	函数，可以是定义或声明
	结构体
	类
	模板
	命名空间，可以嵌套定义
    
//例子
namespace wd
{
    int number = 0;
    void print()
    {
        cout<<"hello"<<endl;
    }
}
访问方式：命名空间的名字 + 作用域限定符 // wd::number
    
命名空间的三种使用形式:
1. using namespace std;
	using是编译指令，一次将命名空间std中的实体全部引出来，而后面自定义命名空间中的实体可能和std中的冲突。
2.类名+作用域限定符
     用std::cin,std::cout就行。
3. using声明机制，一次只引出一个实体(推荐使用哦)
	using std::cin;
	using std::cout;

带命名空间的函数声明，可以定义多次
	namespace wd
	{
    	void print();//声明
	}

命名空间的拓展
结构体是一种类型，后面要加;，不能进行拓展，
自定义和标准的命名空间都可以拓展，
标准命名空间的实体都是以小写字母开头的
    
匿名命名空间
 命名空间还可以不定义名字，不定义名字的命名空间称为匿名命名空间。由于没有名字，该空间中的实
体，其它文件无法引用，它只能在本文件的作用域内有效，它的作用域是从匿名命名空间声明开始到本
文件结束。
namespace 
{
    int val1 = 10;
	void func();
}//end of anonymous namespace
在匿名空间中创建的全局变量，具有全局生存期，却只能被本空间内的函数等访问，是static变量的有效替代手段。访问其中的实体用： ::vall;(作用域限定符+实体)

给命名空间取别名
namespace Television
{...}
namespace Tv = Television;
Tv是命名空间Television的别名
   
~~~

### 命名空间的嵌套使用

~~~c++
int number = 1;
namespace wd
{
	int number = 10;
	namespace wh
	{
		int number = 100;
		void display()
		{
			cout << "wd::wh::display()" << endl;
		}
	}//end of namespace wh
    
	void display(int number)
	{
		cout << "形参number = " << number << endl;
		cout << "wd命名空间中的number = " << wd::number << endl;
		cout << "wh命名空间中的number = " << wd::wh::number << endl;
	}
}//end of namespace wd
int main(void)
{
	using wd::display;
	display();
	return 0;
}
~~~

### 命名空间使用原则

~~~c++
1. 提倡在已命名的命名空间中定义变量，而不是直接定义外部全局变量或者静态全局变量。
2. 如果开发了一个函数库或者类库，提倡将其放在一个名称空间中。
3. 对于using 声明，首先将其作用域设置为局部而不是全局.
    
4. 不要在头文件中使用using编译指令，这样，使得可用名称变得模糊，容易出现二义性，
    
5. 包含头文件的顺序可能会影响程序的行为，如果非要使用using编译指令，建议放在所有#include预编译指令后。
    
~~~

## const关键字的用法

~~~c++
1.const修饰的变量称为const常量(在定义的时候也要初始化)。
内置类型：int,char,short,int,double,float,long,void *,bool等    
const int a = 10;  <=>  int const a = 10;
	发生在编译的时候，若有bug,在编译的时候就可以发现；
c语言中常量定义用宏定义：#define MAX 100
	发生在预处理阶段，若有bug,在运行的时候才会发现。
宏定义没有类型，不做任何类型检查；const常量有具体的类型，在编译期会执行类型检查。
带参数的宏定义：(字符串替换)
	#define MULITY (x,y) ((x)*(y)) -- (x),(y)要看成表达式

2. const修饰指针
  定义空指针：int *p1 = nullptr;
int value = 200;
const int *p2 = &value;//const放在*左右两边都一样
	a.const位于*左边的时候，叫常量指针；//指针指向常量
        不能改变指针所指变量的值，但可以改变指针的指向。
	b.const位于*右边的时候，叫指针常量；//指针本真是常量
        可以改变指针所指变量的值，但不可以改变指针的指向
	c.双const,只读特点
总结：const修饰的是谁，谁就不能改变
        
相近概念：
1. 函数指针 -- 指针指向函数(返回类型 int，参数无参)
    int (*pf) ()
2. 指针函数 -- 函数的返回类型是指针
    int* func()
3.数组指针 -- 指向数组的指针
    int (*parry)[]
4.指针数组 -- 数组的元素类型是数组
    int *parry[]
        
3.const修饰成员函数
4.const修饰对象
	叫常量对象，只能调用const成员函数，数据成员不能修改
~~~

## new/delete表达式

~~~c++
1. malloc使用流程
    a.申请堆空间
    b.初始化
    c.赋值
    d.释放堆空间
    e. p = nullptr;
2.c++中申请堆空间
    a.申请堆空间，初始化，赋值
    int *p1 = new int(100);//开辟一个元素的空间
	int *p2 = new int[10]();//()将数组置为0，开辟一个数组的空间
	b.释放空间
    delete p1;
    delete []p2;//释放数组空间
	p2 = nullptr;

3.相同点
    a.都是用来申请空间；
    b.malloc/free,new/delete要成对出现。
4.不同点
	a. malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符或表达式；
	b. new能够自动分配空间大小，malloc需要传入参数；
	c. new开辟空间的同时还对空间做了初始化的操作，而malloc不行；
	d. new/delete能对对象进行构造和析构函数的调用，进而对内存进行更加详细的工作，而malloc/free不能。
5.既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？
  因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
    
~~~

## 引用 -- 变量的别名

~~~c++
目的：尽量减少指针的使用
变量名实质就是一段连续内存空间的别名
类型 &引用名 = 目标变量名；

int number = 10;
int &ref = number;//引用，前面有类型，ref和number的地址一样
ref = 200;//操作引用与操作变量效果一样

引用的特点：
    1.引用在定义的时候必须初始化，引用不能独立存在；
    2.引用一旦绑定到一个变量上，就不能改变引用的指向；
    3.引用的底层实现就是一个指针，*const(指针常量)；
    4.引用是被限制的指针，所以引用是占据内存的，占据的大小就是一个指针的大小。
    
1.引用作为函数参数 -- 提升效率，减少拷贝
void swap(int &x, int &y)
{
	int temp = x;
	x = y;
	y = temp;
} 
	a.当用引用作为函数的参数时，其效果和用指针作为函数参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或对象的一个别名来使用，也就是说此时函数中对形参的各种操作实际上是对实参本身进行操作，而非简单的将实参变量或对象的值拷贝给形参。
	b.使用指针作为函数的形参虽然达到的效果和使用引用一样，但当调用函数时仍需要为形参指针变量在内存中分配空间，而引用则不需要这样，故在C++中推荐使用引用而非指针作为函数的参数.
	c.采用值传递时，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，即形参变量只是实参变量的副本而已；如果函数传递的是类对象，系统还会调用类中的拷贝构造函数来构造形参对象，假如对象占据的存储空间比较大，那就很不划算了。

2.引用作为函数的返回值
//形式       
类型 &函数名(形参列表)
{
	//函数体
}
返回引用的前提：返回的实体其生命周期一定是要大于函数的生命周期。

规则：
1. 不能返回局部变量的引用。//重要
    主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
2. 不能在函数内部返回new分配的堆空间变量的引用。
    如果返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么该引用所在的空间就无法释放，会造成内存泄漏。
    
//引用总结：
1. 在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递
中，解决大块数据或对象的传递效率和空间不如意的问题。
2. 用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，
保证了引用传递的安全性。
3. 引用与指针的区别是，指针通过某个指针变量指向一个变量后，对它所指向的变量间接操作。程序
中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的
操作。
~~~

### 参数传递

~~~c++
1.参数传递可以传值和引用，尽量传引用，//若传的引用不想被修改，则加const;
返回值传递，尽量传引用；
    
2.临时对象
    类的名称+()，创建新的对象作为临时对象，//X,Y是类类型，所以要传引用哦，
complex	operator+(const complex &x,const complex &y)
{
    return complex(x+real(y),imag(y));
}
若return的东西要放在函数里，则不能返回引用类型，返回本地对象；
    函数要创建一个空间来放新的结果(临时对象)，若函数中本来就存在，则可以传引用。
    比如：
    	int func(int a, int b){
    		return a + b;//因为a+b的结果存放在临时对象中，作用域只在return这一行
		}
		改成：
             int c;
			int& func(int a, int b){
                c = a + b;
                return c;
             }//这样就可以传引用啦
    
~~~

