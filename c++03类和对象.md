# c++03类和对象

## 类和对象

~~~c++
//类中带有指针，不能用默认生成的函数，要有拷贝构造和拷贝赋值，要用动态分配

c是面向过程的语言，按照事物的发展顺序推进；
c++是面向对象，有四大基本特征：抽象，封装，继承，多态。
面向对象的世界里，一切皆对象，对象和对象之间进行交互，使得彼此的状态发生改变。

把具有相同属性的对象抽象出来，形成了类。
    person    类
    属性      数据成员
    方法行为   成员函数
    
类的写法：
class 类名
{
public:
//公有数据成员和成员函数
protected:
//保护数据成员和成员函数
private:
//私有数据成员和成员函数
}; // 千万不要忘了这个分号

public进行修饰的成员表示的是该类可以提供的接口、功能、或者服务；
protected进行修饰的成员，其访问权限是开放给其子类；
private进行修饰的成员是不可以在类之外进行访问的，只能在类内部访问，可以说封装性就是由该关键字来体现。
    
在类中定义的成员函数，都是inline函数。除了可以在类内部实现外，成员函数还可以在类之外实现。在类定义的外部定义成员函数时，应使用作用域限定符（::）来标识函数所属的类，
    返回类型 类名::成员函数名(参数列表)
	{
		//....
	}

~~~

## class与struct的区别

~~~c++
在C++中，与C相比，struct的功能已经进行了扩展。
class能做的事儿，struct一样能做，他们之间唯一的区别，就是默认访问权限不同。
class的默认访问权限是private，struct的默认访问权限是public
~~~

## 编程规范

~~~c++
1.头文件书写顺序：
	a.自定义的头文件
	b.c的头文件
	c.c++的头文件
2.代码的功能模块要写块注释，难理解以及重要的地方要写行注释，学会编写技术文档。
3.函数名的第二个单词首字母大写，setBrand()；
4.private里面的数据成员一般写下面，以下划线开头(方便识别);
5.变量函数的命名要贴近含义；
6.代码分成头文件(.h)，实现文件(.cc),测试文件(.cc)，放在一起用 g++ *.cc 编译
~~~

## 构造函数 -- ctor

~~~c++
目的：为了初始化数据成员；
调用时机：对象创建的时候会自动调用；
特点：
	1.可以重载，一般分无参构造函数，有参构造函数；
	2.与类名相同，没有返回值和返回类型；
如何调用？
    编译器会生成一个默认的无参构造函数；有自定义的构造函数的时候，编译器就不会生成啦。

形式：
class Point
{
public:
//...
	Point(int ix = 0, int iy = 0)
	: _ix(ix)
	, _iy(iy)  //初始化列表后，对象已经构建好啦。
	{  //这个函数体里面主要进行复制操作
	cout << "Point(int = 0,int = 0)" << endl;
	}
//...
};
//只传入一个值的时候也可以哦
Point(int ix )
	: _ix(ix)
	, _iy(_ix) 
        
数据成员初始化的顺序不是由成员变量在初始化列表中的顺序决定的，而是由成员变量在类中被声明时的顺序决定的。

~~~

## 析构函数 -- dtor

~~~c++
//不带指针的类多半不用写析构函数,用系统默认的就可以
目的：完成数据成员的清理工作
调用时机：对象超出其作用域被销毁时，析构函数会被自动调用。
特点：
	1.只能有一个哦
	2.没有返回值，返回类型，没有参数
	3.与类同名，之前加~
    4.。如果没有显式的定义它，系统也会提供一个默认的析构函数
形式：
~ Computer()
{
    if(_brand){
    	delete [] _brand;
        _brand = nullptr;
    }
}

和构造函数的比较
1.构造函数不能用对象加.的形式调用，但可以单独调用，调用的时候也会创建对象，但周期只在那一行
2.析构函数可以用对象加.的形式调用(显式调用)，但不建议使用

析构函数在哪些时候会被调用呢？
1. 对于全局定义的对象，每当程序开始运行，在主函数main接受程序控制权之前，就调用构造函数
创建全局对象，整个程序结束时，自动调用全局对象的析构函数。
2. 对于局部定义的对象，每当程序流程到达该对象的定义处就调用构造函数，在程序离开局部对象的
作用域时调用对象的析构函数。
3. 对于关键字static定义的静态局部变量，当程序流程第一次到达该对象定义处调用构造函数，在整
个程序结束时调用析构函数。
4. 对于用new运算符创建的对象，每当创建该对象时调用构造函数，当用delete删除该对象时，调用
析构函数。 
~~~

## 拷贝构造函数

~~~c++
//默认的拷贝构造函数是浅拷贝，自己写要写深拷贝

1.默认情况下，编译器会自动生成一个拷贝构造函数，用的是浅拷贝；
//系统默认的拷贝构造函数，浅拷贝
Computer::Computer(const Computer &rhs) //注意形参类型是自己的类哦
: _brand(rhs._brand)
, _price(rhs._price)
{
}
//执行构造初始化
Computer pc1("Huawei Matebook14", 5699);
Computer pc2 = pc1;

浅拷贝：pc与pc对象的数据成员_brand都会指向同一个堆空间的字符串，只拷贝指针的地
址；
深拷贝：拷贝指针所指空间的内容，因为两个对象都拥有各自的独立堆空间字符串，一个对象销毁时就不会影响另一个对象。

2.拷贝构造函数指向同一个地址问题
  用深拷贝解决，申请空间并复制，但是可能内存重叠的问题；
Computer::Computer(const Computer & rhs)
: _brand(new char[strlen(rhs._brand) + 1]())
, _price(rhs._price)
{
	strcpy(_brand, rhs._brand);
}

3.拷贝构造函数的调用时机
时机1：用一个已经存在的对象，去初始化一个刚创建的对象的时候；
时机2：当实参和形参都是对象，进行实参与形参的结合的时候；
时机3：当函数的返回类型是类的时候，函数调用完成返回时(执行return时，有拷贝性质)，会调用拷贝构造函数，因为编译器做了优化，看不到效果可以将优化开关打开(-fno-elide-constructors)。
~~~

